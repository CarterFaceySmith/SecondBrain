Linux binaries are executable files compiled to run on the Linux operating system. The Executable and Linkable Format (ELF) is a common file format for [[Linux]] binaries. 

## Intro

Linux binaries are files containing machine code and data in a format that the Linux operating system can directly execute. ELF is the standard file format for executables, object code, shared libraries, and core dumps on Linux systems.

They are generated by compiling source code into an ELF object file (`.o`), which is then used by a [[Linkers]] with other ELF files to generated an ELF executable.

## Varieties

1. *Relocatable*: Created during [[Compilation]] but need to be processed by the [[Linkers]] before running.
2. *Executable*: All relocation done and all symbols resolved except maybe shared [[Object Code Libraries]] symbols to be resolved at runtime.
3. *Shared*: Shared libraries containing both symbol information for the [[Linkers]] and directly runnable code for runtime.

## Structure

- **Header**: Contains essential information about the file, such as file type, target architecture, and entry point.
- **Sections**: Segments of the file containing various data like code, data, symbols, and relocation information.
- **Segments**: Logical units for loading the program into memory, including one or more sections.
- **Symbols**: Information about functions, variables, etc., used for linking.

### Full Structure Example

```
ELF header
.text
.data
.rodata
.bss
.sym
.rel.text
.rel.data
.rel.rodata
.line
.debug
.strtab
(section table, not considered to be a section)
```

## A Practical Example of an ELF Header

```
char magic[4] = "\177ELF";// magic number
char class; // address size, 1 = 32 bit, 2 = 64 bit
char byteorder; // 1 = little-endian, 2 = big-endian
char hversion; // header version, always 1
char pad[9];
short filetype; // file type: 1 = relocatable, 2 = executable,
// 3 = shared object, 4 = core image
short archtype; // 2 = SPARC, 3 = x86, 4 = 68K, etc.
int fversion; // file version, always 1
int entry; // entry point if executable
int phdrpos; // file position of program header or 0
int shdrpos; // file position of section header or 0
int flags; // architecture specific flags, usually 0
short hdrsize; // size of this ELF header
short phdrent; // size of an entry in program header
short phdrcnt; // number of entries in program header or 0
short shdrent; // size of an entry in section header
short phdrcnt; // number of entries in section header or 0
short strsec; // section number that contains section name strings
```

## A Practical Example of an ELF Symbol Table

```
int name; // position of name string in string table
int value; // symbol value, section relative in reloc,
// absolute in executable
int size; // object or function size
char type:4; // data object, function, section, or special case file
char bind:4; // local, global, or weak
char other; // spare
short sect; // section number, ABS, COMMON or UNDEF
```

### Specific Sections

- **`.text`**: Contains the executable code.
- **`.data`**: Holds initialized global and static variables.
- **`.bss`**: Contains uninitialized global and static variables.
- **`.rodata`**: Holds read-only data like constants and string literals.
- **`.symtab`**: Stores symbol information.
- **`.rel.text` and `.rel.data`**: Contain relocation information for code and data.

## Manipulating ELF Files

**Viewing ELF Information**: Use tools like `readelf` to inspect ELF file information, including headers, sections, and symbols.

```bash
readelf -h your_executable  # Display ELF header 
readelf -S your_executable  # Display ELF sections`
```

- **Modifying ELF Information**: Tools like `objcopy` can modify ELF files, such as extracting sections or changing the binary format.

- **Creating Custom ELF Tools**: With appropriate knowledge, you can develop custom tools to parse and manipulate ELF files for specific purposes.

## Key ELF Linux Libraries

### Linker and Loader Libraries
#### **libelf**
- **Description**: `libelf` is a library that provides functions for reading and writing ELF files, making it essential for creating custom ELF file loaders or manipulation tools.
- **Usage**: Allows you to parse ELF structures, access segments, sections, symbols, and more.

#### **libdwarf**
- **Description**: `libdwarf` is used for reading DWARF debugging information, which is typically embedded in ELF files. It's useful for debugging and profiling applications.
- **Usage**: Provides functions to navigate and extract debugging information from ELF files.

### Libraries for ELF Manipulation
#### **libc**
- **Description**: The C standard library (`libc`) provides essential functions and utilities for various operations, including file I/O, memory allocation, string manipulation, and system calls.
- **Usage**: Utilize functions like `mmap` for memory mapping ELF files, `dlopen` for dynamic loading, and others for general file operations.

### Memory Management Libraries
#### **libmman**
- **Description**: `libmman` provides functions related to memory management, including memory mapping (`mmap`) and memory allocation (`malloc`, `calloc`, `realloc`).
- **Usage**: Use `mmap` to map ELF files into memory for efficient loading and manipulation.

### Error Handling Libraries
#### **liberr**
- **Description**: Error handling is critical in ELF file loading. Libraries like `liberr` help in robust error reporting and handling.
- **Usage**: Implement error handling strategies using functions provided by this library, such as logging and graceful degradation.

## A Practical Example

1. Grab your [[Assembly]] code
```assembly
section .data
    hello db 'Hello, ELF!',0

section .text
    global _start

_start:
    ; sys_write(int fd, const char *buf, int count)
    mov eax, 4
    mov ebx, 1
    mov ecx, hello
    mov edx, 13
    int 0x80

    ; sys_exit(int status)
    mov eax, 1
    xor ebx, ebx
    int 0x80
```

**Sections**:
- The assembly code is divided into two sections: `.data` and `.text`.
- The `.data` section is for initialised data, and the `.text` section is for executable code.

**Global Declaration**:
- `global _start` declares the `_start` label as a global symbol. The `_start` label is typically the entry point of the program.

**Program Entry Point**:
- `_start:`: This is the entry point of the program.

**System Call to Write**:
- `mov eax, 4`: Moves the system call number for `sys_write` (system call for writing to a file descriptor) into the `eax` register.
- `mov ebx, 1`: Moves the file descriptor for standard output (STDOUT) into the `ebx` register.
- `mov ecx, hello`: Moves the address of the `hello` string (`.data` section) into the `ecx` register (pointer to the data to be written).
- `mov edx, 13`: Moves the length of the string to be written (13 bytes including the null terminator) into the `edx` register.
- `int 0x80`: Triggers a software interrupt (system call).

**System Call to Exit**:
- `mov eax, 1`: Moves the system call number for `sys_exit` (system call for program termination) into the `eax` register.
- `xor ebx, ebx`: Clears the `ebx` register (status code for exit).
- `int 0x80`: Triggers a software interrupt (system call) to exit the program.

**String Declaration**:
- `hello db 'Hello, ELF!',0`: Declares a null-terminated ASCII string "Hello, ELF!" in the `.data` section. `db` is used to define bytes.

2. Assemble and link that shit

```bash
as -o example.o example.asm      # Assemble to object file
ld -m elf_i386 -s -o example example.o  # Link to create ELF executable
```

3. You're now free to analyse or use your ELF file using `readelf` or `objdump`.